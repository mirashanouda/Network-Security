#### In our implementation, Alice and Bob update their Diffie-Hellman ratchets each time they exchange messages. Is it possible to modify the protocol so that they update the DH ratchets only once every ten messages without compromising confidentiality against an eavesdropper, i.e., maintaining semantic security?
Yes, it is theoretically possible to keep a count of the number of DH key exchange. In our implementation, we depend on encrypting the message using a message key generated from KDF using a chain key that both keep updating. However, this will expose the system to a venerability if a chain key is compromised then in the worst case 10 consecutive messages would be revealed. Hence, there is a trade off here between the efficiency by decreasing the rate we exchange DH key and the security to ensure that any message attack will not compromise future or past messages.  

#### What if they never update DH ratchets? Explain the consequences according to forward secrecy and break-in recovery.
In case the DH ratchets were never updated, then in case of an attack that managed to get the chain key of the sending or receiving chains, it would be easy to reveal all future messages and generate the message keys to decrypt the future messages which violates the principle of break-in recovery. However, since the past chain keys are not stored then the attack will never be able to decrypt past messages which maintain the principle of forward secrecy.

#### Our messaging system depends on the platform to verify the authenticity of usersâ€™ public keys. However, we are also aiming to provide users with confidentiality from the platform. Given the partial trust we place in it, how could a malicious platform potentially gain access to the contents of a message that one user is sending to another?
In a platform using the Double Ratchet Algorithm, since the platform verifies the authenticity of users' public keys, a malicious could substitute the real public keys with its own, allowing it to decrypt messages intended for another user, read or alter them, and then re-encrypt with the recipient's actual public key.

#### Look-up how real end-to-end encrypted messaging applications refrain from this problem, and provide a solution.
In actual end-to-end encrypted messaging applications typically use mechanisms like Trust On First Use (TOFU) or a Public Key Infrastructure (PKI) with certificates verified by a trusted Certificate Authority (CA) to ensure public keys' authenticity. Users may also manually verify each other's keys through methods like QR code scanning or sharing a fingerprint of the key out-of-band. This helps prevent a malicious platform from swapping out public keys, as users have a direct way to ensure they're using the correct keys for communication.